# -*- coding: utf-8 -*-
"""
Created on Sat Jun 29 06:50:05 2024

@author: jinxu
"""


"""
This code is to plot the average approximation ratios of the random selection
and the heuristic selection schemes over constructed Eulerian multigraphs
for different graph parameters

There are three selection schemes based on the multigraph generated by CPP
naive_cpp: each time select the first eligible node from V_next
random_cpp: each time select a random eligible node from V_next
heuristic_cpp: each time select the node with the highest potential score from V_next


There are three selection schemes based on the multigraph generated by duplicating edges of the original graph 
naive_dup: each time select the first eligible node from V_next
random_dup: each time select a random eligible node from V_next
heuristic_dup: each time select the node with the highest potential score from V_next

"""

import random
import numpy as np
import networkx as nx 
import itertools
import copy
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt
import aoi_utils


def ratio(n,p):
    N = 1000
    #the number of the target graphs
    
    # naive_cpp_aoi = np.zeros(N)
    heu_cpp_aoi = np.zeros(N)
    random_cpp_aoi = np.zeros(N)
    
    # naive_dup_aoi = np.zeros(N)
    heu_dup_aoi = np.zeros(N)
    random_dup_aoi = np.zeros(N)
    
    tsp_aoi = np.zeros(N)
    
    case = 0
    n_edges = 0
    
    while True:
        if case >= N:
            break
        
        #to randomly generate graphs using the erdos-renyi approach
        g = nx.erdos_renyi_graph(n, p, seed=None, directed=False)
            
        n_edges += g.number_of_edges()
    
        
        #to guarantee that each graph is connect and non-eulerian and planar
        # if nx.is_planar(g) ==  True and nx.is_eulerian(g) == False and nx.is_connected(g) == True:
            
        #to guarantee that each graph is connect and non-eulerian
        if nx.is_eulerian(g) == False and nx.is_connected(g) == True:
            if case%100 == 0:
                print(case)
      
            #randomly generate the weight of edges
            for (u,v,w) in g.edges(data=True):
                w['weight'] = np.random.rand()*10
                # w['weight'] = np.random.lognormal(0,1)
                # w['weight'] = np.random.exponential(1)
            g_array = nx.to_numpy_array(g)    
            
            # below we generate an Eulerian multigraph based on CPP
            g_aug = aoi_utils.smallest_eularian_graph(g)
            source = 0
            
            #the lower bound of the AoI given by 1/2*l(E)**2, Lemma 1 of the paper        
            lower_bound = sum(nx.get_edge_attributes(g, 'weight').values())**2/2
    
            #generate circuits on the CPP graph
            # naive_circuit = aoi_utils.deter_eulerian_circuit(g_aug, source)
            heuristic_circuit = aoi_utils.heuristic_AoI_eulerian_circuit(g_aug, source)
            random_eulerian_circuit = aoi_utils.random_eulerian_circuit(g_aug, source)
            
            #below we generate an Eulerian multigraph by duplicating each edge of the original graph
            g_dup = aoi_utils.add_augmenting_path_to_graph(g, g.edges())
    
            #generate circuits on the duplicated graph        
            # naive_circuit_dup = aoi_utils.deter_eulerian_circuit(g_dup, source)
            heuristic_circuit_dup = aoi_utils.heuristic_AoI_eulerian_circuit(g_dup, source)
            random_eulerian_circuit_dup = aoi_utils.random_eulerian_circuit(g_dup, source)
            
            #to compute the approximation ratios of each algorithm
            # naive_cpp_aoi[case] += aoi_utils.AoI_Compute(g_array,naive_circuit)/lower_bound
            heu_cpp_aoi[case] = aoi_utils.AoI_Compute(g_array,heuristic_circuit)/lower_bound
            random_cpp_aoi[case] = aoi_utils.AoI_Compute(g_array,random_eulerian_circuit)/lower_bound
            
            # naive_dup_aoi[case] = aoi_utils.AoI_Compute(g_array,naive_circuit_dup)/lower_bound
            heu_dup_aoi[case] = aoi_utils.AoI_Compute(g_array,heuristic_circuit_dup)/lower_bound
            random_dup_aoi[case] = aoi_utils.AoI_Compute(g_array,random_eulerian_circuit_dup)/lower_bound
    
            tsp_circuit = aoi_utils.tsp_circuit(g)
            tsp_aoi[case] = aoi_utils.AoI_Compute(g_array,tsp_circuit)/lower_bound
    
            case += 1
        
    return np.mean(heu_cpp_aoi), np.mean(random_cpp_aoi), np.mean(heu_dup_aoi), np.mean(random_dup_aoi), np.mean(tsp_aoi),\
        np.std(heu_cpp_aoi), np.std(random_cpp_aoi), np.std(heu_dup_aoi), np.std(random_dup_aoi), np.std(tsp_aoi)



"""
plot the average approximation ratio of algorithms
"""
# grid = 19
# plot_x = np.linspace(4,22,grid)
# plot_y = np.zeros((5,grid))
# plot_y1 = np.zeros((5,grid))

# p0 = 0.2

# for i in range(grid):
#     print('epoch',i)
#     temp = ratio(int(plot_x[i]),p0)
#     plot_y[:,i] = temp[0:5]
#     plot_y1[:,i] = temp[5:]


# matplotlib.rcParams.update({'font.size': 22})
# fig, ax = plt.subplots(figsize=(9, 6))
# plt.plot(plot_x,plot_y[0,:],linestyle = '-',marker='o',markersize=10,color='lightgreen',linewidth=2,label = 'heu_cpp')
# # plt.fill_between(plot_x,plot_y[0,:]-plot_y1[0,:], plot_y[0,:]+plot_y1[0,:] ,alpha=0.3, facecolor='lightgreen')

# plt.plot(plot_x,plot_y[1,:],linestyle = '--',marker='o',markersize=10,color='lightblue',linewidth=2,label = 'rand_cpp')
# # plt.fill_between(plot_x,plot_y[1,:]-plot_y1[1,:], plot_y[1,:]+plot_y1[1,:] ,alpha=0.3, facecolor='lightblue')

# plt.plot(plot_x,plot_y[2,:],linestyle = '-',marker='*',markersize=10,color='slategrey',linewidth=2,label = 'heu_dup')
# # plt.fill_between(plot_x,plot_y[2,:]-plot_y1[2,:], plot_y[2,:]+plot_y1[2,:] ,alpha=0.3, facecolor='slategrey')

# plt.plot(plot_x,plot_y[3,:],linestyle = '--',marker='*',markersize=10,color='lightpink',linewidth=2,label = 'rand_dup')
# # plt.fill_between(plot_x,plot_y[3,:]-plot_y1[3,:], plot_y[3,:]+plot_y1[3,:] ,alpha=0.3, facecolor='lightpink')

# plt.plot(plot_x,plot_y[4,:],linestyle = '-.',marker='v',markersize=10,color='orange',linewidth=2,label = 'tsp_heu')
# # plt.fill_between(plot_x,plot_y[3,:]-plot_y1[3,:], plot_y[3,:]+plot_y1[3,:] ,alpha=0.3, facecolor='lightpink')

# plt.legend(loc='upper right')
# plt.xlabel(r'$n$')
# plt.xticks(plot_x[::2])
# plt.ylabel('Ratio')
# plt.show()
# plt.tight_layout()
# fig.savefig('Graph_7_1_new.pdf', dpi=800, format='pdf')

grid = 11
plot_x = np.linspace(0.1,0.6,grid)
plot_y = np.zeros((5,grid))
plot_y1 = np.zeros((5,grid))

for i in range(grid):
    print('epoch',i)
    temp = ratio(12,plot_x[i])
    plot_y[:,i] = temp[0:5]
    plot_y1[:,i] = temp[5:]


matplotlib.rcParams.update({'font.size': 22})
fig, ax = plt.subplots(figsize=(9, 6))
plt.plot(plot_x,plot_y[0,:],linestyle = '-',marker='o',markersize=10,color='lightgreen',linewidth=2,label = 'heu_cpp')
# plt.fill_between(plot_x,plot_y[0,:]-plot_y1[0,:], plot_y[0,:]+plot_y1[0,:] ,alpha=0.3, facecolor='lightgreen')

plt.plot(plot_x,plot_y[1,:],linestyle = '--',marker='o',markersize=10,color='lightblue',linewidth=2,label = 'rand_cpp')
# plt.fill_between(plot_x,plot_y[1,:]-plot_y1[1,:], plot_y[1,:]+plot_y1[1,:] ,alpha=0.3, facecolor='lightblue')

plt.plot(plot_x,plot_y[2,:],linestyle = '-',marker='*',markersize=10,color='slategrey',linewidth=2,label = 'heu_dup')
# plt.fill_between(plot_x,plot_y[2,:]-plot_y1[2,:], plot_y[2,:]+plot_y1[2,:] ,alpha=0.3, facecolor='slategrey')

plt.plot(plot_x,plot_y[3,:],linestyle = '--',marker='*',markersize=10,color='lightpink',linewidth=2,label = 'rand_dup')
# plt.fill_between(plot_x,plot_y[3,:]-plot_y1[3,:], plot_y[3,:]+plot_y1[3,:] ,alpha=0.3, facecolor='lightpink')

plt.plot(plot_x,plot_y[4,:],linestyle = '-.',marker='v',markersize=10,color='orange',linewidth=2,label = 'tsp_heu')

plt.legend(loc='upper right')
plt.xlabel(r'$p$')
plt.xticks(plot_x[::2])
plt.ylabel('Ratio')
plt.show()
plt.tight_layout()
fig.savefig('Graph_7_2_new.pdf', dpi=800, format='pdf')